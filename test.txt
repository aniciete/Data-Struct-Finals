# Test Cases for Data Structures Project

# =================================
# Input Utilities
# =================================
# Test getIntegerInput()
# Description: Test with various inputs to ensure robustness.
# Input: "abc"
# Expected: Error message, re-prompt
# Input: "" (empty string)
# Expected: Error message, re-prompt
# Input: "12345678901234567890" (overflow)
# Expected: Error message, re-prompt
# Input: "-10"
# Expected: -10
# Input: "0"
# Expected: 0

# =================================
# Stack
# =================================
# Test Static Stack (assuming size 5)
# Action: PUSH 1, PUSH 2, PUSH 3, PUSH 4, PUSH 5
# Action: PUSH 6
# Expected: Stack Overflow error
# Action: POP until empty
# Action: POP
# Expected: Stack Underflow error
# Action: PEEK on empty stack
# Expected: Stack Underflow error

# Test Dynamic Stack
# Action: POP on new empty stack
# Expected: Stack is empty message
# Action: PEEK on new empty stack
# Expected: Stack is empty message
# Action: PUSH 1000 elements, then POP 1000 elements
# Expected: Success, no memory leaks

# =================================
# Queue
# =================================
# Test Static Queue (assuming size 5)
# Action: ENQUEUE 1, ENQUEUE 2, ENQUEUE 3, ENQUEUE 4, ENQUEUE 5
# Action: ENQUEUE 6
# Expected: Queue is full error
# Action: DEQUEUE until empty
# Action: DEQUEUE
# Expected: Queue is empty error
# Action: Test circular behavior
# Action: ENQUEUE 1, 2, 3. DEQUEUE 1, 2. ENQUEUE 4, 5, 6.
# Expected: Queue should contain 3, 4, 5, 6. (or similar depending on implementation)

# Test Dynamic Queue
# Action: DEQUEUE on new empty queue
# Expected: Queue is empty message
# Action: PEEK on new empty queue
# Expected: Queue is empty message

# =================================
# Binary Search Tree
# =================================
# Action: INSERT 10, 5, 15, 5
# Expected: Second '5' is ignored or handled.
# Action: DELETE 5 (node with one child if duplicates aren't inserted)
# Expected: Success
# Action: INSERT 20, 12. DELETE 15 (node with two children)
# Expected: Success, tree remains valid BST.
# Action: DELETE 10 (root)
# Expected: Success, new root is correct.
# Action: SEARCH 99
# Expected: Value not found.
# Action: TRAVERSE (In-order, Pre-order, Post-order) on empty tree
# Expected: Empty tree message.

# =================================
# Graph
# =================================
# Action: ADD_EDGE 99 -> 100 on a graph without these vertices
# Expected: Error message (Vertex not found).
# Action: Create disconnected graph (e.g., 1-2, 3-4).
# Action: BFS/DFS from vertex 1.
# Expected: Only visits 1 and 2.
# Action: BFS/DFS from vertex 99
# Expected: Error message (Vertex not found).
# Action: Perform operations on an empty graph
# Expected: Graceful handling (e.g., "Graph is empty").

# =================================
# Sorting Algorithms
# =================================
# Test Array: [] (empty)
# Expected: No change, no error.
# Test Array: [1, 2, 3, 4, 5] (sorted)
# Expected: [1, 2, 3, 4, 5]
# Test Array: [5, 4, 3, 2, 1] (reverse-sorted)
# Expected: [1, 2, 3, 4, 5]
# Test Array: [3, 1, 4, 1, 5, 9, 2, 6] (duplicates)
# Expected: [1, 1, 2, 3, 4, 5, 6, 9]
# Test Array: [large number of random elements]
# Expected: Sorted array, reasonable performance.